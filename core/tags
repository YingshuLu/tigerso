!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALLLOG	Logging.h	/^	ALLLOG = 3$/;"	e	enum:tigerso::LOGLEVEL
COMMENT	ConfigParser.h	26;"	d
COMTB	ConfigParser.h	16;"	d
CONFIGFILE	tigerso.h	/^const std::string  CONFIGFILE  =  CONFIGPATH + "\/" + PROJECT  +".ini";$/;"	m	namespace:tigerso::core
CONFIGPATH	tigerso.h	/^const std::string  CONFIGPATH  =  WORKPATH + "\/etc";$/;"	m	namespace:tigerso::core
Condition	Condition.h	/^    Condition(ThreadMutex& mutex)$/;"	f	class:tigerso::Condition
Condition	Condition.h	/^class Condition: public nocopyable {$/;"	c	namespace:tigerso
ConfigParser	ConfigParser.h	/^	ConfigParser() :isFileExisted(false), isRefreshed(false){}$/;"	f	class:tigerso::ConfigParser
ConfigParser	ConfigParser.h	/^class ConfigParser$/;"	c	namespace:tigerso
CurrentThread	CurrentThread.h	/^namespace CurrentThread {$/;"	n	namespace:tigerso
CurrentThread	Thread.cpp	/^namespace CurrentThread {$/;"	n	namespace:tigerso	file:
DBG_LOG	Logging.h	24;"	d
DEBUG	Logging.h	/^	DEBUG = 2,$/;"	e	enum:tigerso::LOGLEVEL
DEFAULT_SHM_MUTEX_FILENAME	SysUtil.h	/^const string DEFAULT_SHM_MUTEX_FILENAME = "TIGERSOSHMMUTEX";$/;"	m	namespace:tigerso
ERRLINE	ConfigParser.h	28;"	d
ERR_RETURN	Logging.h	26;"	d
FILE_ACTION_OK	File.h	26;"	d
FILE_ARGS_INVALID	File.h	31;"	d
FILE_BIG_CONTENT	File.h	24;"	d
FILE_FD_INVALID	File.h	30;"	d
FILE_NAME_MAX_LENGTH	File.h	25;"	d
FILE_OPEN_ERROR	File.h	27;"	d
FILE_READ_ACCESS_DENY	File.h	29;"	d
FILE_SENDFILE_DONE	File.h	35;"	d
FILE_SENDFILE_ERROR	File.h	33;"	d
FILE_SENDFILE_RECALL	File.h	34;"	d
FILE_WRITE_ACCESS_DENY	File.h	28;"	d
File	File.cpp	/^File::File() {}$/;"	f	class:tigerso::File
File	File.cpp	/^File::File(const char* filename) {$/;"	f	class:tigerso::File
File	File.h	/^class File {$/;"	c	namespace:tigerso
FileLock	FileLock.cpp	/^FileLock::FileLock(const std::string& filename, const std::string& content): filename_(filename), content_(content) {$/;"	f	class:tigerso::FileLock
FileLock	FileLock.h	/^class FileLock: public Lock {$/;"	c	namespace:tigerso
GLOBAL	tigerso.h	36;"	d
HEX2CHAR	Dechex.cpp	14;"	d	file:
HEXCHAR2DEC	Dechex.cpp	13;"	d	file:
HEX_DIV	Dechex.cpp	12;"	d	file:
HEX_MOD	Dechex.cpp	11;"	d	file:
HOST_MAXLENGTH	tigerso.h	38;"	d
HexCharSet	Dechex.cpp	/^static const char HexCharSet[] = {$/;"	m	namespace:tigerso	file:
INFO	Logging.h	/^	INFO = 1,$/;"	e	enum:tigerso::LOGLEVEL
INFO_LOG	Logging.h	25;"	d
IPV4_ADDRSIZE	tigerso.h	37;"	d
KEYB	ConfigParser.h	17;"	d
KEYVAL	ConfigParser.h	27;"	d
LOCK_FAILURE	FileLock.h	10;"	d
LOCK_SUCCESS	FileLock.h	9;"	d
LOGLEVEL	Logging.h	/^enum LOGLEVEL{$/;"	g	namespace:tigerso
LOGNAME	tigerso.h	/^const std::string  LOGNAME     =  "httpd";$/;"	m	namespace:tigerso::core
LOGPATH	tigerso.h	/^const std::string  LOGPATH     =  WORKPATH + "\/log";$/;"	m	namespace:tigerso::core
Lock	SysUtil.h	/^class Lock: public nocopyable {$/;"	c	namespace:tigerso
LockGuard	SysUtil.h	/^   explicit LockGuard(Lock& Lock)$/;"	f	class:tigerso::LockGuard
LockGuard	SysUtil.h	/^class LockGuard {$/;"	c	namespace:tigerso
LockTryGuard	SysUtil.h	/^    explicit LockTryGuard(Lock& Lock)$/;"	f	class:tigerso::LockTryGuard
LockTryGuard	SysUtil.h	/^class LockTryGuard {$/;"	c	namespace:tigerso
Lock_obj	SysUtil.h	/^    Lock& Lock_obj;$/;"	m	class:tigerso::LockGuard
Lock_obj	SysUtil.h	/^    Lock& Lock_obj;$/;"	m	class:tigerso::LockTryGuard
Logging	Logging.h	/^	Logging():endFmt("<__FUNC__>@__FILE__"), level(NOLOG){}$/;"	f	class:tigerso::Logging
Logging	Logging.h	/^class Logging {$/;"	c	namespace:tigerso
MC_LOCK_PRIVATE	SysUtil.h	/^const int MC_LOCK_PRIVATE = 0;$/;"	m	namespace:tigerso
MC_LOCK_SHARE_PROCESS	SysUtil.h	/^const int MC_LOCK_SHARE_PROCESS = 1;$/;"	m	namespace:tigerso
NOLOG	Logging.h	/^	NOLOG = 0,$/;"	e	enum:tigerso::LOGLEVEL
PROJECT	tigerso.h	/^const std::string  PROJECT     =  "tigerso";$/;"	m	namespace:tigerso::core
PUSH2HEXBUF	Dechex.cpp	15;"	d	file:
REVERSESTRING	Dechex.cpp	16;"	d	file:
REVERSE_STRING	Dechex.cpp	/^void REVERSE_STRING(char* beg, char* end) {$/;"	f	namespace:tigerso
SECTB	ConfigParser.h	14;"	d
SECTE	ConfigParser.h	15;"	d
SECTION	ConfigParser.h	25;"	d
SPLIT	Logging.h	16;"	d
SPLIT	Logging.h	19;"	d
SharedMemory	SysUtil.h	/^    SharedMemory():$/;"	f	class:tigerso::SharedMemory
SharedMemory	SysUtil.h	/^    SharedMemory(const string& name, const size_t size, const int prot = MAP_SHARED):$/;"	f	class:tigerso::SharedMemory
SharedMemory	SysUtil.h	/^class SharedMemory: public nocopyable {$/;"	c	namespace:tigerso
ShmMutex	SysUtil.cpp	/^ShmMutex::ShmMutex()$/;"	f	class:tigerso::ShmMutex
ShmMutex	SysUtil.cpp	/^ShmMutex::ShmMutex(const ShmMutex& mutex)$/;"	f	class:tigerso::ShmMutex
ShmMutex	SysUtil.cpp	/^ShmMutex::ShmMutex(const string& shm_name)$/;"	f	class:tigerso::ShmMutex
ShmMutex	SysUtil.h	/^class ShmMutex: public Lock {$/;"	c	namespace:tigerso
SysUtil	SysUtil.h	/^class SysUtil {$/;"	c	namespace:tigerso
TEST_FILEACCESS	File.h	22;"	d
TIGERSO_IO_CLOSE	tigerso.h	/^    TIGERSO_IO_CLOSE = -2,$/;"	e	enum:tigerso::_TIGERSO_IO_STATE_
TIGERSO_IO_ERROR	tigerso.h	/^    TIGERSO_IO_ERROR = -1,$/;"	e	enum:tigerso::_TIGERSO_IO_STATE_
TIGERSO_IO_OK	tigerso.h	/^    TIGERSO_IO_OK$/;"	e	enum:tigerso::_TIGERSO_IO_STATE_
TIGERSO_IO_RECALL	tigerso.h	/^    TIGERSO_IO_RECALL,$/;"	e	enum:tigerso::_TIGERSO_IO_STATE_
TS_CORE_BASECLASS_H_	BaseClass.h	2;"	d
TS_CORE_CONDITION_H_	Condition.h	2;"	d
TS_CORE_CONFIGPARSER_H_	ConfigParser.h	2;"	d
TS_CORE_CURRENTTHREAD_H_	CurrentThread.h	2;"	d
TS_CORE_DECHEX_H_	Dechex.h	2;"	d
TS_CORE_FILELOCK_H_	FileLock.h	2;"	d
TS_CORE_FILE_H_	File.h	2;"	d
TS_CORE_LOGGING_H_	Logging.h	7;"	d
TS_CORE_PTHREAD_H_	Thread.h	2;"	d
TS_CORE_SYSUTIL_H_	SysUtil.h	2;"	d
TS_CORE_THREADMUTEX_H_	ThreadMutex.h	2;"	d
TS_CORE_THREADPOOL_H_	ThreadPool.h	2;"	d
TS_CORE_TIGERSO_H_	tigerso.h	2;"	d
Task	ThreadPool.h	/^    typedef Thread::ThreadFunc Task;$/;"	t	class:tigerso::ThreadPool
Thread	Thread.cpp	/^Thread::Thread(const ThreadFunc& func, const std::string& name)$/;"	f	class:tigerso::Thread
Thread	Thread.h	/^class Thread: public nocopyable {$/;"	c	namespace:tigerso
ThreadData	Thread.cpp	/^    ThreadData(const ThreadFunc& func,$/;"	f	class:tigerso::ThreadData
ThreadData	Thread.cpp	/^class ThreadData {$/;"	c	namespace:tigerso	file:
ThreadFunc	Thread.cpp	/^    typedef Thread::ThreadFunc ThreadFunc;$/;"	t	class:tigerso::ThreadData	file:
ThreadFunc	Thread.h	/^    typedef std::function<void()>  ThreadFunc;$/;"	t	class:tigerso::Thread
ThreadInit	Thread.cpp	/^    ThreadInit() {$/;"	f	class:tigerso::initmain__::ThreadInit
ThreadInit	Thread.cpp	/^class ThreadInit {$/;"	c	namespace:tigerso::initmain__	file:
ThreadMutex	ThreadMutex.h	/^    ThreadMutex()$/;"	f	class:tigerso::ThreadMutex
ThreadMutex	ThreadMutex.h	/^class ThreadMutex: public Lock {$/;"	c	namespace:tigerso
ThreadPool	ThreadPool.h	/^    explicit ThreadPool(const std::string& name = "ThreadPool")$/;"	f	class:tigerso::ThreadPool
ThreadPool	ThreadPool.h	/^class ThreadPool: public nocopyable {$/;"	c	namespace:tigerso
ThreadPtr	ThreadPool.h	/^    typedef std::shared_ptr<Thread> ThreadPtr;$/;"	t	class:tigerso::ThreadPool
UnassignGuard	ThreadMutex.h	/^        UnassignGuard(ThreadMutex& mutex)$/;"	f	class:tigerso::ThreadMutex::UnassignGuard
UnassignGuard	ThreadMutex.h	/^    class UnassignGuard {$/;"	c	class:tigerso::ThreadMutex
VERSION	tigerso.h	/^const std::string  VERSION     =  "1.0.0";$/;"	m	namespace:tigerso::core
WORKPATH	tigerso.h	/^const std::string  WORKPATH    =  "\/usr\/" + PROJECT;$/;"	m	namespace:tigerso::core
_TIGERSO_IO_STATE_	tigerso.h	/^typedef enum _TIGERSO_IO_STATE_ {$/;"	g	namespace:tigerso
afterFork	Thread.cpp	/^void afterFork() {$/;"	f	namespace:tigerso::initmain__
appendWriteIn	File.cpp	/^ssize_t File::appendWriteIn(const char* buf, size_t len) {$/;"	f	class:tigerso::File
assignHolder	ThreadMutex.h	/^    void assignHolder() {$/;"	f	class:tigerso::ThreadMutex
blocking	tigerso.h	59;"	d
cacheTid_	Thread.cpp	/^   __thread int cacheTid_ = 0;$/;"	m	namespace:tigerso::CurrentThread	file:
close	File.h	/^    int close() { int ret = ::close(fd_); fd_ = -1; }$/;"	f	class:tigerso::File
cond_	Condition.h	/^    pthread_cond_t cond_;$/;"	m	class:tigerso::Condition
configMap	ConfigParser.h	/^	std::map<std::string, std::map<std::string, std::string> > configMap;$/;"	m	class:tigerso::ConfigParser
content_	FileLock.h	/^    std::string content_;$/;"	m	class:tigerso::FileLock
continuousReadOut	File.cpp	/^ssize_t File::continuousReadOut(char* buf, size_t len) {$/;"	f	class:tigerso::File
core	tigerso.h	/^namespace core {$/;"	n	namespace:tigerso
create_process_shared_memory	SysUtil.cpp	/^void* SysUtil::create_process_shared_memory(const string& shm_name, size_t len, bool clear)$/;"	f	class:tigerso::SysUtil
cur_	File.h	/^    off_t cur_;$/;"	m	class:tigerso::File
dbgLog	Logging.cpp	/^int Logging::dbgLog(const char* fmt, ...)$/;"	f	class:tigerso::Logging
dec2hex	Dechex.cpp	/^const char* dec2hex(unsigned int num) {$/;"	f	namespace:tigerso
decideLineType	ConfigParser.cpp	/^int ConfigParser::decideLineType(const std::string& line, std::string& content)$/;"	f	class:tigerso::ConfigParser
destroy	FileLock.cpp	/^int FileLock::destroy() {$/;"	f	class:tigerso::FileLock
destroy	SysUtil.cpp	/^int SharedMemory::destroy() {$/;"	f	class:tigerso::SharedMemory
destroy	SysUtil.cpp	/^int ShmMutex::destroy()$/;"	f	class:tigerso::ShmMutex
destroy	ThreadMutex.h	/^    int destroy() {$/;"	f	class:tigerso::ThreadMutex
destroy_process_shared_memory	SysUtil.cpp	/^int SysUtil::destroy_process_shared_memory(const string& shm_name, void* ptr, size_t len)$/;"	f	class:tigerso::SysUtil
endFmt	Logging.h	/^	const std::string endFmt;$/;"	m	class:tigerso::Logging
fd_	File.h	/^    int fd_;$/;"	m	class:tigerso::File
fd_	FileLock.h	/^    int fd_;$/;"	m	class:tigerso::FileLock
filename	ConfigParser.h	/^	std::string filename;$/;"	m	class:tigerso::ConfigParser
filename_	File.h	/^    char filename_[FILE_NAME_MAX_LENGTH] = {0};$/;"	m	class:tigerso::File
filename_	FileLock.h	/^    std::string filename_;$/;"	m	class:tigerso::FileLock
func_	Thread.cpp	/^    ThreadFunc func_;$/;"	m	class:tigerso::ThreadData	file:
func_	Thread.h	/^    ThreadFunc func_;$/;"	m	class:tigerso::Thread
getAllKey	ConfigParser.cpp	/^void ConfigParser::getAllKey()$/;"	f	class:tigerso::ConfigParser
getFileSize	File.cpp	/^ssize_t File::getFileSize() {$/;"	f	class:tigerso::File
getFormatTime	SysUtil.cpp	/^string SysUtil::getFormatTime(const string& fmt){$/;"	f	class:tigerso::SysUtil
getInstance	ConfigParser.cpp	/^ConfigParser* ConfigParser::getInstance()$/;"	f	class:tigerso::ConfigParser
getInstance	Logging.cpp	/^Logging* Logging::getInstance()$/;"	f	class:tigerso::Logging
getLogFile	Logging.cpp	/^std::string Logging::getLogFile() const$/;"	f	class:tigerso::Logging
getThreadMutex	ThreadMutex.h	/^    pthread_mutex_t* getThreadMutex() {$/;"	f	class:tigerso::ThreadMutex
getTime	Logging.cpp	/^std::string Logging::getTime()$/;"	f	class:tigerso::Logging
getValueByKey	ConfigParser.cpp	/^std::string ConfigParser::getValueByKey(const std::string& section, const std::string& key)$/;"	f	class:tigerso::ConfigParser
get_shm_mutex	SysUtil.cpp	/^shm_mutex_t* ShmMutex::get_shm_mutex() const$/;"	f	class:tigerso::ShmMutex
get_shm_name	SysUtil.cpp	/^string ShmMutex::get_shm_name() const$/;"	f	class:tigerso::ShmMutex
get_shm_ptr	SysUtil.cpp	/^void* SharedMemory::get_shm_ptr() const {$/;"	f	class:tigerso::SharedMemory
get_work_path	SysUtil.cpp	/^string SysUtil::get_work_path()$/;"	f	class:tigerso::SysUtil
hex2dec	Dechex.cpp	/^unsigned int hex2dec(const char* hex) {$/;"	f	namespace:tigerso
hexstrbuf	Dechex.cpp	/^static char hexstrbuf[9] = {0};$/;"	m	namespace:tigerso	file:
holder_	ThreadMutex.h	/^    pid_t holder_ = 0;$/;"	m	class:tigerso::ThreadMutex
infoLog	Logging.cpp	/^int Logging::infoLog(const char* fmt, ...)$/;"	f	class:tigerso::Logging
init	FileLock.cpp	/^int FileLock::init() {$/;"	f	class:tigerso::FileLock
init	SysUtil.cpp	/^int SharedMemory::init() {$/;"	f	class:tigerso::SharedMemory
init	SysUtil.cpp	/^int ShmMutex::init()$/;"	f	class:tigerso::ShmMutex
init	Thread.cpp	/^ThreadInit init;$/;"	m	namespace:tigerso::initmain__	file:
init	ThreadMutex.h	/^    int init() {$/;"	f	class:tigerso::ThreadMutex
initmain__	Thread.cpp	/^namespace initmain__ {$/;"	n	namespace:tigerso	file:
isFileExisted	ConfigParser.h	/^	bool isFileExisted;$/;"	m	class:tigerso::ConfigParser
isFull	ThreadPool.h	/^    bool isFull() const {$/;"	f	class:tigerso::ThreadPool
isLocked	SysUtil.h	/^    bool isLocked() const {$/;"	f	class:tigerso::LockTryGuard
isLocked	SysUtil.h	/^    bool isLocked() { return locked_ ; }$/;"	f	class:tigerso::ShmMutex
isLockedByCurrentThread	ThreadMutex.h	/^    bool isLockedByCurrentThread() const {$/;"	f	class:tigerso::ThreadMutex
isMainThread	CurrentThread.h	/^   inline bool isMainThread() { return CurrentThread::tid() == getpid(); }$/;"	f	namespace:tigerso::CurrentThread
isReadDone	File.h	/^    bool isReadDone() { return readdone_; }$/;"	f	class:tigerso::File
isRefreshed	ConfigParser.h	/^	bool isRefreshed;$/;"	m	class:tigerso::ConfigParser
join	Thread.cpp	/^int Thread::join() {$/;"	f	class:tigerso::Thread
joined_	Thread.h	/^    bool joined_ = false;$/;"	m	class:tigerso::Thread
level	Logging.h	/^	int level;$/;"	m	class:tigerso::Logging
loadConfig2Map	ConfigParser.cpp	/^int ConfigParser::loadConfig2Map()$/;"	f	class:tigerso::ConfigParser
lock	FileLock.cpp	/^int FileLock::lock() {$/;"	f	class:tigerso::FileLock
lock	SysUtil.cpp	/^int ShmMutex::lock()$/;"	f	class:tigerso::ShmMutex
lock	ThreadMutex.h	/^    int lock() {$/;"	f	class:tigerso::ThreadMutex
lock_cmd	FileLock.cpp	/^int FileLock::lock_cmd(int cmd) {$/;"	f	class:tigerso::FileLock
locked	SysUtil.h	/^    bool locked;$/;"	m	class:tigerso::LockTryGuard
locked_	FileLock.h	/^    bool locked_ = false;$/;"	m	class:tigerso::FileLock
locked_	SysUtil.h	/^    bool locked_ = false;$/;"	m	class:tigerso::ShmMutex
locked_pid	SysUtil.h	/^    pid_t locked_pid;$/;"	m	class:tigerso::ShmMutex
logFile	Logging.h	/^	std::string logFile;$/;"	m	class:tigerso::Logging
logPath	Logging.h	/^	std::string logPath;$/;"	m	class:tigerso::Logging
loopmutex_	ThreadPool.h	/^    mutable ThreadMutex loopmutex_;$/;"	m	class:tigerso::ThreadPool
make_dirtree	SysUtil.cpp	/^int SysUtil::make_dirtree(const string& dirname)$/;"	f	class:tigerso::SysUtil
mutex	SysUtil.h	/^    pthread_mutex_t mutex;$/;"	m	struct:tigerso::shm_mutex_t
mutex_	Condition.h	/^    ThreadMutex& mutex_;$/;"	m	class:tigerso::Condition
mutex_	ThreadMutex.h	/^    pthread_mutex_t  mutex_;$/;"	m	class:tigerso::ThreadMutex
mutex_	ThreadPool.h	/^    mutable ThreadMutex mutex_;$/;"	m	class:tigerso::ThreadPool
mutex_ptr	SysUtil.h	/^    shm_mutex_t* mutex_ptr;$/;"	m	class:tigerso::ShmMutex
mutexattr	SysUtil.h	/^    pthread_mutexattr_t mutexattr;$/;"	m	struct:tigerso::shm_mutex_t
name	CurrentThread.h	/^   inline const char* name() { return threadName_; }$/;"	f	namespace:tigerso::CurrentThread
name	Thread.h	/^    const std::string& name() { return name_; }$/;"	f	class:tigerso::Thread
name_	Thread.cpp	/^    std::string name_;$/;"	m	class:tigerso::ThreadData	file:
name_	Thread.h	/^    std::string name_="";$/;"	m	class:tigerso::Thread
name_	ThreadPool.h	/^    std::string name_;$/;"	m	class:tigerso::ThreadPool
nocopyable	BaseClass.h	/^    nocopyable(){}$/;"	f	class:tigerso::nocopyable
nocopyable	BaseClass.h	/^class nocopyable {$/;"	c	namespace:tigerso
nonBlocking	tigerso.h	58;"	d
notEmpty	ThreadPool.h	/^    bool notEmpty = false;$/;"	m	class:tigerso::ThreadPool
notEmpty_	ThreadPool.h	/^    Condition notEmpty_;$/;"	m	class:tigerso::ThreadPool
notFull	ThreadPool.h	/^    bool notFull = true;$/;"	m	class:tigerso::ThreadPool
notFull_	ThreadPool.h	/^    Condition notFull_;$/;"	m	class:tigerso::ThreadPool
notify	Condition.h	/^    void notify() {$/;"	f	class:tigerso::Condition
notifyAll	Condition.h	/^    void notifyAll() {$/;"	f	class:tigerso::Condition
numCreated	Thread.h	/^    static int numCreated() { return numCreated_.load(); }$/;"	f	class:tigerso::Thread
numCreated_	Thread.h	/^    static std::atomic<int> numCreated_;$/;"	m	class:tigerso::Thread
operator =	SysUtil.cpp	/^ShmMutex ShmMutex::operator=(const ShmMutex& mutex)$/;"	f	class:tigerso::ShmMutex
owner_	ThreadMutex.h	/^        ThreadMutex& owner_;$/;"	m	class:tigerso::ThreadMutex::UnassignGuard
pInstance	BaseClass.h	/^    static singleton* pInstance; $/;"	m	class:tigerso::singleton
pInstance	ConfigParser.cpp	/^ConfigParser* ConfigParser::pInstance = NULL;$/;"	m	class:tigerso::ConfigParser	file:
pInstance	ConfigParser.h	/^	static ConfigParser* pInstance;$/;"	m	class:tigerso::ConfigParser
pInstance	Logging.cpp	/^Logging* Logging::pInstance = NULL;$/;"	m	class:tigerso::Logging	file:
pInstance	Logging.h	/^	static Logging* pInstance;$/;"	m	class:tigerso::Logging
readOut	File.cpp	/^ssize_t File::readOut(char* buf, size_t len, off_t& offset) {$/;"	f	class:tigerso::File
readdone_	File.h	/^    bool readdone_ = false;$/;"	m	class:tigerso::File
refer_num	SysUtil.h	/^    int refer_num;$/;"	m	struct:tigerso::shm_mutex_t
reload	ConfigParser.cpp	/^int ConfigParser::reload() {$/;"	f	class:tigerso::ConfigParser
remove_file	SysUtil.cpp	/^int SysUtil::remove_file(const string& file)$/;"	f	class:tigerso::SysUtil
reset	File.h	/^    inline void reset() { ::close(fd_); fd_ = -1; size_ = 0; cur_ = 0; }$/;"	f	class:tigerso::File
run	ThreadPool.h	/^    void run(const Task task) {$/;"	f	class:tigerso::ThreadPool
runInThread	Thread.cpp	/^    void runInThread() {$/;"	f	class:tigerso::ThreadData
runInThread	ThreadPool.h	/^    void runInThread() {$/;"	f	class:tigerso::ThreadPool
running_	ThreadPool.h	/^    std::atomic<bool> running_;$/;"	m	class:tigerso::ThreadPool
send2Socket	File.cpp	/^int File::send2Socket(int sockfd, size_t& sendn) {$/;"	f	class:tigerso::File
send2Socket	File.cpp	/^int File::send2Socket(int sockfd, size_t& sendn, off_t& offset, size_t count) {$/;"	f	class:tigerso::File
setBlockingIO	File.h	/^    inline int setBlockingIO(int block) { if(validFd(fd_)) { return block != 1? nonBlocking(fd_): blocking(fd_); } return -1; }$/;"	f	class:tigerso::File
setConfigPath	ConfigParser.cpp	/^void ConfigParser::setConfigPath(const std::string& file)$/;"	f	class:tigerso::ConfigParser
setDefaultName	Thread.cpp	/^void Thread::setDefaultName() {$/;"	f	class:tigerso::Thread
setFilename	File.cpp	/^void File::setFilename(const char* filename) {$/;"	f	class:tigerso::File
setLevel	Logging.cpp	/^int Logging::setLevel(const std::string& le)$/;"	f	class:tigerso::Logging
setLogFile	Logging.cpp	/^int Logging::setLogFile(const std::string& file)$/;"	f	class:tigerso::Logging
setLogPath	Logging.cpp	/^int Logging::setLogPath(const std::string& path)$/;"	f	class:tigerso::Logging
set_signal_handler	SysUtil.cpp	/^signal_func* SysUtil::set_signal_handler(int signo, signal_func* func) {$/;"	f	class:tigerso::SysUtil
shm_len	SysUtil.h	/^    size_t shm_len;$/;"	m	class:tigerso::SharedMemory
shm_mutex_t	SysUtil.h	/^struct shm_mutex_t {$/;"	s	namespace:tigerso
shm_name	SysUtil.h	/^    char shm_name[1024];$/;"	m	struct:tigerso::shm_mutex_t
shm_name	SysUtil.h	/^    string shm_name;$/;"	m	class:tigerso::SharedMemory
shm_name	SysUtil.h	/^    string shm_name;$/;"	m	class:tigerso::ShmMutex
shm_pid	SysUtil.h	/^    pid_t shm_pid;$/;"	m	class:tigerso::SharedMemory
shm_pid	SysUtil.h	/^    pid_t shm_pid;$/;"	m	class:tigerso::ShmMutex
shm_prot	SysUtil.h	/^    int shm_prot;$/;"	m	class:tigerso::SharedMemory
shm_ptr	SysUtil.h	/^    void* shm_ptr;$/;"	m	class:tigerso::SharedMemory
signal_func	SysUtil.h	/^typedef void (signal_func)(int);$/;"	t	namespace:tigerso
singleton	BaseClass.h	/^class singleton {$/;"	c	namespace:tigerso
size_	File.h	/^    off_t size_;$/;"	m	class:tigerso::File
start	Thread.cpp	/^void Thread::start() {$/;"	f	class:tigerso::Thread
start	ThreadPool.h	/^    void start(const int threadNum) {$/;"	f	class:tigerso::ThreadPool
startThread	Thread.cpp	/^void* startThread(void* obj) {$/;"	f	namespace:tigerso
start_	Thread.h	/^    bool start_ = false;$/;"	m	class:tigerso::Thread
started	Thread.h	/^    bool started() const { return start_; }$/;"	f	class:tigerso::Thread
stop	ThreadPool.h	/^    void stop() {$/;"	f	class:tigerso::ThreadPool
take	ThreadPool.h	/^    Task take() {$/;"	f	class:tigerso::ThreadPool
tasks_	ThreadPool.h	/^    std::deque<Task> tasks_;$/;"	m	class:tigerso::ThreadPool
testExist	File.h	/^    inline bool testExist() { return TEST_FILEACCESS(filename_, F_OK); }$/;"	f	class:tigerso::File
testRead	File.h	/^    inline bool testRead()  { return TEST_FILEACCESS(filename_, R_OK); }$/;"	f	class:tigerso::File
testWrite	File.h	/^    inline bool testWrite() { return TEST_FILEACCESS(filename_, W_OK); }$/;"	f	class:tigerso::File
threadId_	Thread.h	/^    pthread_t threadId_ = 0;$/;"	m	class:tigerso::Thread
threadName_	Thread.cpp	/^   __thread const char* threadName_ = "unknow thread";$/;"	m	namespace:tigerso::CurrentThread	file:
threadNum_	ThreadPool.h	/^    int threadNum_;$/;"	m	class:tigerso::ThreadPool
threads_	ThreadPool.h	/^    std::vector<ThreadPtr> threads_;$/;"	m	class:tigerso::ThreadPool
tid	Thread.cpp	/^   pid_t tid() {$/;"	f	namespace:tigerso::CurrentThread
tid	Thread.h	/^    pid_t tid() const { return *tid_; }$/;"	f	class:tigerso::Thread
tidStrLength	Thread.cpp	/^   __thread size_t tidStrLength = 0;$/;"	m	namespace:tigerso::CurrentThread	file:
tidString	CurrentThread.h	/^   inline const char* tidString() { return tidString_; }$/;"	f	namespace:tigerso::CurrentThread
tidString_	Thread.cpp	/^   __thread char tidString_[32] = {0};$/;"	m	namespace:tigerso::CurrentThread	file:
tid_	Thread.h	/^    std::shared_ptr<pid_t> tid_;$/;"	m	class:tigerso::Thread
tigerso	BaseClass.h	/^namespace tigerso {$/;"	n
tigerso	Condition.h	/^namespace tigerso{$/;"	n
tigerso	ConfigParser.cpp	/^namespace tigerso {$/;"	n	file:
tigerso	ConfigParser.h	/^namespace tigerso {$/;"	n
tigerso	CurrentThread.h	/^namespace tigerso {$/;"	n
tigerso	Dechex.cpp	/^namespace tigerso {$/;"	n	file:
tigerso	Dechex.h	/^namespace tigerso {$/;"	n
tigerso	File.cpp	/^namespace tigerso {$/;"	n	file:
tigerso	File.h	/^namespace tigerso {$/;"	n
tigerso	FileLock.cpp	/^namespace tigerso {$/;"	n	file:
tigerso	FileLock.h	/^namespace tigerso {$/;"	n
tigerso	Logging.cpp	/^namespace tigerso {$/;"	n	file:
tigerso	Logging.h	/^namespace tigerso {$/;"	n
tigerso	SysUtil.cpp	/^namespace tigerso {$/;"	n	file:
tigerso	SysUtil.h	/^namespace tigerso {$/;"	n
tigerso	Thread.cpp	/^namespace tigerso {$/;"	n	file:
tigerso	Thread.h	/^namespace tigerso {$/;"	n
tigerso	ThreadMutex.h	/^namespace tigerso {$/;"	n
tigerso	ThreadPool.h	/^namespace tigerso {$/;"	n
tigerso	tigerso.h	/^namespace tigerso {$/;"	n
toLower	SysUtil.h	/^    void toLower(std::string& src, std::string& dst) { std::transform(src.begin(), src.end(), dst.begin(), ::tolower); }$/;"	f	class:tigerso::SysUtil
toUpper	SysUtil.h	/^    void toUpper(std::string& src, std::string& dst) { std::transform(src.begin(), src.end(), dst.begin(), ::toupper); }$/;"	f	class:tigerso::SysUtil
try_lock	FileLock.cpp	/^int FileLock::try_lock() {$/;"	f	class:tigerso::FileLock
try_lock	SysUtil.cpp	/^int ShmMutex::try_lock()$/;"	f	class:tigerso::ShmMutex
try_lock	ThreadMutex.h	/^    int try_lock() {$/;"	f	class:tigerso::ThreadMutex
unassignHolder	ThreadMutex.h	/^    void unassignHolder() {$/;"	f	class:tigerso::ThreadMutex
unlink	File.h	/^    inline int unlink() { return ::unlink(filename_); }$/;"	f	class:tigerso::File
unlock	FileLock.cpp	/^int FileLock::unlock() {$/;"	f	class:tigerso::FileLock
unlock	SysUtil.cpp	/^int ShmMutex::unlock()$/;"	f	class:tigerso::ShmMutex
unlock	ThreadMutex.h	/^    int unlock() {$/;"	f	class:tigerso::ThreadMutex
validFd	tigerso.h	60;"	d
validate_filename	SysUtil.cpp	/^bool SysUtil::validate_filename(const string& filename)$/;"	f	class:tigerso::SysUtil
wait	Condition.h	/^    void wait() {$/;"	f	class:tigerso::Condition
waitForSeconds	Condition.h	/^    bool waitForSeconds(double seconds) {$/;"	f	class:tigerso::Condition
wkTid_	Thread.cpp	/^    std::weak_ptr<pid_t> wkTid_;$/;"	m	class:tigerso::ThreadData	file:
writeIn	File.cpp	/^ssize_t File::writeIn(const char* buf, size_t len) {$/;"	f	class:tigerso::File
~Condition	Condition.h	/^    ~Condition() {$/;"	f	class:tigerso::Condition
~ConfigParser	ConfigParser.h	/^    ~ConfigParser() { delete pInstance; }$/;"	f	class:tigerso::ConfigParser
~File	File.cpp	/^File::~File() {$/;"	f	class:tigerso::File
~FileLock	FileLock.cpp	/^FileLock::~FileLock() {$/;"	f	class:tigerso::FileLock
~LockGuard	SysUtil.h	/^    ~LockGuard() {$/;"	f	class:tigerso::LockGuard
~LockTryGuard	SysUtil.h	/^    ~LockTryGuard() {$/;"	f	class:tigerso::LockTryGuard
~SharedMemory	SysUtil.h	/^    ~SharedMemory() {$/;"	f	class:tigerso::SharedMemory
~ShmMutex	SysUtil.cpp	/^ShmMutex::~ShmMutex()$/;"	f	class:tigerso::ShmMutex
~Thread	Thread.cpp	/^Thread::~Thread() {$/;"	f	class:tigerso::Thread
~ThreadMutex	ThreadMutex.h	/^    ~ThreadMutex() {$/;"	f	class:tigerso::ThreadMutex
~UnassignGuard	ThreadMutex.h	/^        ~UnassignGuard() {$/;"	f	class:tigerso::ThreadMutex::UnassignGuard
~nocopyable	BaseClass.h	/^    ~nocopyable(){}$/;"	f	class:tigerso::nocopyable
~singleton	BaseClass.h	/^    virtual ~singleton(){ if ( pInstance != nullptr) { delete pInstance; } };$/;"	f	class:tigerso::singleton
