="programlisting"><a href="libxml-tree.html#xmlDtdPtr">xmlDtdPtr</a>	xmlParseDTD		(const <a href="libxml-xmlstring.html#xmlChar">xmlChar</a> * ExternalID, <br />					 const <a href="libxml-xmlstring.html#xmlChar">xmlChar</a> * SystemID)<br />
</pre><p>Load and parse an external subset.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ExternalID</tt></i>:</span></td><td>a NAME* containing the External ID of the DTD</td></tr><tr><td><span class="term"><i><tt>SystemID</tt></i>:</span></td><td>a NAME* containing the URL to the DTD</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting <a href="libxml-tree.html#xmlDtdPtr">xmlDtdPtr</a> or NULL in case of error.</td></tr></tbody></table></div><h3><a name="xmlParseDoc" id="xmlParseDoc"></a>Function: xmlParseDoc</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlParseDoc		(const <a href="libxml-xmlstring.html#xmlChar">xmlChar</a> * cur)<br />
</pre><p>parse an XML in-memory document and build a tree.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>a pointer to an array of <a href="libxml-xmlstring.html#xmlChar">xmlChar</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlParseDocument" id="xmlParseDocument"></a>Function: xmlParseDocument</h3><pre class="programlisting">int	xmlParseDocument		(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><p>parse an XML document (and build a tree if using the standard SAX interface). [1] document ::= prolog element Misc* [22] prolog ::= XMLDecl? Misc* (doctypedecl Misc*)?</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0, -1 in case of error. the parser context is augmented as a result of the parsing.</td></tr></tbody></table></div><h3><a name="xmlParseEntity" id="xmlParseEntity"></a>Function: xmlParseEntity</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlParseEntity		(const char * filename)<br />
</pre><p>parse an XML external entity out of context and build a tree. [78] extParsedEnt ::= TextDecl? content This correspond to a "Well Balanced" chunk</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>the filename</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlParseExtParsedEnt" id="xmlParseExtParsedEnt"></a>Function: xmlParseExtParsedEnt</h3><pre class="programlisting">int	xmlParseExtParsedEnt		(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><p>parse a general parsed entity An external general parsed entity is well-formed if it matches the production labeled extParsedEnt. [78] extParsedEnt ::= TextDecl? content</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0, -1 in case of error. the parser context is augmented as a result of the parsing.</td></tr></tbody></table></div><h3><a name="xmlParseExternalEntity" id="xmlParseExternalEntity"></a>Function: xmlParseExternalEntity</h3><pre class="programlisting">int	xmlParseExternalEntity		(<a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a> doc, <br />					 <a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />					 void * user_data, <br />					 int depth, <br />					 const <a href="libxml-xmlstring.html#xmlChar">xmlChar</a> * URL, <br />					 const <a href="libxml-xmlstring.html#xmlChar">xmlChar</a> * ID, <br />					 <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> * lst)<br />
</pre><p>Parse an external general entity An external general parsed entity is well-formed if it matches the production labeled extParsedEnt. [78] extParsedEnt ::= TextDecl? content</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>doc</tt></i>:</span></td><td>the document the chunk pertains to</td></tr><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler bloc (possibly NULL)</td></tr><tr><td><span class="term"><i><tt>user_data</tt></i>:</span></td><td>The user data returned on SAX callbacks (possibly NULL)</td></tr><tr><td><span class="term"><i><tt>depth</tt></i>:</span></td><td>Used for loop detection, use 0</td></tr><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the URL for the entity to load</td></tr><tr><td><span class="term"><i><tt>ID</tt></i>:</span></td><td>the System ID for the entity to load</td></tr><tr><td><span class="term"><i><tt>lst</tt></i>:</span></td><td>the return value for the set of parsed nodes</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the entity is well formed, -1 in case of args problem and the parser error code otherwise</td></tr></tbody></table></div><h3><a name="xmlParseFile" id="xmlParseFile"></a>Function: xmlParseFile</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlParseFile		(const char * filename)<br />
</pre><p>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>the filename</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree if the file was wellformed, NULL otherwise.</td></tr></tbody></table></div><h3><a name="xmlParseInNodeContext" id="xmlParseInNodeContext"></a>Function: xmlParseInNodeContext</h3><pre class="programlisting"><a href="libxml-xmlerror.html#xmlParserErrors">xmlParserErrors</a>	xmlParseInNodeContext	(<a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> node, <br />					 const char * data, <br />					 int datalen, <br />					 int options, <br />					 <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> * lst)<br />
</pre><p>Parse a well-balanced chunk of an XML document within the context (DTD, namespaces, etc ...) of the given node. The allowed sequence for the data is a Well Balanced Chunk defined by the content production in the XML grammar: [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>node</tt></i>:</span></td><td>the context node</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>the input string</td></tr><tr><td><span class="term"><i><tt>datalen</tt></i>:</span></td><td>the input string length in bytes</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of <a href="libxml-parser.html#xmlParserOption">xmlParserOption</a></td></tr><tr><td><span class="term"><i><tt>lst</tt></i>:</span></td><td>the return value for the set of parsed nodes</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td><a href="libxml-xmlerror.html#XML_ERR_OK">XML_ERR_OK</a> if the chunk is well balanced, and the parser error code otherwise</td></tr></tbody></table></div><h3><a name="xmlParseMemory" id="xmlParseMemory"></a>Function: xmlParseMemory</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlParseMemory		(const char * buffer, <br />					 int size)<br />
</pre><p>parse an XML in-memory block and build a tree.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>an pointer to a char array</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>the size of the array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlParserAddNodeInfo" id="xmlParserAddNodeInfo"></a>Function: xmlParserAddNodeInfo</h3><pre class="programlisting">void	xmlParserAddNodeInfo		(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />					 const <a href="libxml-parser.html#xmlParserNodeInfoPtr">xmlParserNodeInfoPtr</a> info)<br />
</pre><p>Insert node info record into the sorted sequence</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>a node info sequence pointer</td></tr></tbody></table></div><h3><a name="xmlParserFindNodeInfo" id="xmlParserFindNodeInfo"></a>Function: xmlParserFindNodeInfo</h3><pre class="programlisting">const <a href="libxml-parser.html#xmlParserNodeInfo">xmlParserNodeInfo</a> *	xmlParserFindNodeInfo	(const <a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctx, <br />							 const <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> node)<br />
</pre><p>Find the parser node info struct for a given node</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>node</tt></i>:</span></td><td>an XML node within the tree</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>an <a href="libxml-parser.html#xmlParserNodeInfo">xmlParserNodeInfo</a> block pointer or NULL</td></tr></tbody></table></div><h3><a name="xmlParserFindNodeInfoIndex" id="xmlParserFindNodeInfoIndex"></a>Function: xmlParserFindNodeInfoIndex</h3><pre class="programlisting">unsigned long	xmlParserFindNodeInfoIndex	(const <a href="libxml-parser.html#xmlParserNodeInfoSeqPtr">xmlParserNodeInfoSeqPtr</a> seq, <br />						 const <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> node)<br />
</pre><p><a href="libxml-parser.html#xmlParserFindNodeInfoIndex">xmlParserFindNodeInfoIndex</a> : Find the index that the info record for the given node is or should be at in a sorted sequence</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>seq</tt></i>:</span></td><td>a node info sequence pointer</td></tr><tr><td><span class="term"><i><tt>node</tt></i>:</span></td><td>an XML node pointer</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a long indicating the position of the record</td></tr></tbody></table></div><h3><a name="xmlParserInputDeallocate" id="xmlParserInputDeallocate"></a>Function type: xmlParserInputDeallocate</h3><pre class="programlisting">Function type: xmlParserInputDeallocate
void	xmlParserInputDeallocate	(<a href="libxml-xmlstring.html#xmlChar">xmlChar</a> * str)
</pre><p>Callback for freeing some parser input allocations.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>str</tt></i>:</span></td><td>the string to deallocate</td></tr></tbody></table></div><br />
<h3><a name="xmlParserInputGrow" id="xmlParserInputGrow"></a>Function: xmlParserInputGrow</h3><pre class="programlisting">int	xmlParserInputGrow		(<a href="libxml-tree.html#xmlParserInputPtr">xmlParserInputPtr</a> in, <br />					 int len)<br />
</pre><p>This function increase the input for the parser. It tries to preserve pointers to the input buffer, and keep already read data</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>in</tt></i>:</span></td><td>an XML parser input</td></tr><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>an indicative size for the lookahead</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the amount of char read, or -1 in case of error, 0 indicate the end of this entity</td></tr></tbody></table></div><h3><a name="xmlParserInputRead" id="xmlParserInputRead"></a>Function: xmlParserInputRead</h3><pre class="programlisting">int	xmlParserInputRead		(<a href="libxml-tree.html#xmlParserInputPtr">xmlParserInputPtr</a> in, <br />					 int len)<br />
</pre><p>This function was internal and is deprecated.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>in</tt></i>:</span></td><td>an XML parser input</td></tr><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>an indicative size for the lookahead</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 as this is an error to use it.</td></tr></tbody></table></div><h3><a name="xmlPedanticParserDefault" id="xmlPedanticParserDefault"></a>Function: xmlPedanticParserDefault</h3><pre class="programlisting">int	xmlPedanticParserDefault	(int val)<br />
</pre><p>Set and return the previous value for enabling pedantic warnings.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>val</tt></i>:</span></td><td>int 0 or 1</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the last value for 0 for no substitution, 1 for substitution.</td></tr></tbody></table></div><h3><a name="xmlReadDoc" id="xmlReadDoc"></a>Function: xmlReadDoc</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlReadDoc		(const <a href="libxml-xmlstring.html#xmlChar">xmlChar</a> * cur, <br />					 const char * URL, <br />					 const char * encoding, <br />					 int options)<br />
</pre><p>parse an XML in-memory document and build a tree.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>a pointer to a zero terminated string</td></tr><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the base URL to use for the document</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of <a href="libxml-parser.html#xmlParserOption">xmlParserOption</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlReadFd" id="xmlReadFd"></a>Function: xmlReadFd</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlReadFd		(int fd, <br />					 const char * URL, <br />					 const char * encoding, <br />					 int options)<br />
</pre><p>parse an XML from a file descriptor and build a tree. NOTE that the file descriptor will not be closed when the reader is closed or reset.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>fd</tt></i>:</span></td><td>an open file descriptor</td></tr><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the base URL to use for the document</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of <a href="libxml-parser.html#xmlParserOption">xmlParserOption</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlReadFile" id="xmlReadFile"></a>Function: xmlReadFile</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlReadFile		(const char * filename, <br />					 const char * encoding, <br />					 int options)<br />
</pre><p>parse an XML file from the filesystem or the network.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>a file or URL</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of <a href="libxml-parser.html#xmlParserOption">xmlParserOption</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlReadIO" id="xmlReadIO"></a>Function: xmlReadIO</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlReadIO		(<a href="libxml-xmlIO.html#xmlInputReadCallback">xmlInputReadCallback</a> ioread, <br />					 <a href="libxml-xmlIO.html#xmlInputCloseCallback">xmlInputCloseCallback</a> ioclose, <br />					 void * ioctx, <br />					 const char * URL, <br />					 const char * encoding, <br />					 int options)<br />
</pre><p>parse an XML document from I/O functions and source and build a tree.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ioread</tt></i>:</span></td><td>an I/O read function</td></tr><tr><td><span class="term"><i><tt>ioclose</tt></i>:</span></td><td>an I/O close function</td></tr><tr><td><span class="term"><i><tt>ioctx</tt></i>:</span></td><td>an I/O handler</td></tr><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the base URL to use for the document</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of <a href="libxml-parser.html#xmlParserOption">xmlParserOption</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlReadMemory" id="xmlReadMemory"></a>Function: xmlReadMemory</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlReadMemory		(const char * buffer, <br />					 int size, <br />					 const char * URL, <br />					 const char * encoding, <br />					 int options)<br />
</pre><p>parse an XML in-memory document and build a tree.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>a pointer to a char array</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>the size of the array</td></tr><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the base URL to use for the document</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of <a href="libxml-parser.html#xmlParserOption">xmlParserOption</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlRecoverDoc" id="xmlRecoverDoc"></a>Function: xmlRecoverDoc</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlRecoverDoc		(const <a href="libxml-xmlstring.html#xmlChar">xmlChar</a> * cur)<br />
</pre><p>parse an XML in-memory document and build a tree. In the case the document is not Well Formed, a attempt to build a tree is tried anyway</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>a pointer to an array of <a href="libxml-xmlstring.html#xmlChar">xmlChar</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree or NULL in case of failure</td></tr></tbody></table></div><h3><a name="xmlRecoverFile" id="xmlRecoverFile"></a>Function: xmlRecoverFile</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlRecoverFile		(const char * filename)<br />
</pre><p>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. In the case the document is not Well Formed, it attempts to build a tree anyway</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>the filename</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree or NULL in case of failure</td></tr></tbody></table></div><h3><a name="xmlRecoverMemory" id="xmlRecoverMemory"></a>Function: xmlRecoverMemory</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlRecoverMemory	(const char * buffer, <br />					 int size)<br />
</pre><p>parse an XML in-memory block and build a tree. In the case the document is not Well Formed, an attempt to build a tree is tried anyway</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>an pointer to a char array</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>the size of the array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree or NULL in case of error</td></tr></tbody></table></div><h3><a name="xmlSAXParseDTD" id="xmlSAXParseDTD"></a>Function: xmlSAXParseDTD</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDtdPtr">xmlDtdPtr</a>	xmlSAXParseDTD		(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />					 const <a href="libxml-xmlstring.html#xmlChar">xmlChar</a> * ExternalID, <br />					 const <a href="libxml-xmlstring.html#xmlChar">xmlChar</a> * SystemID)<br />
</pre><p>Load and parse an external subset.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler block</td></tr><tr><td><span class="term"><i><tt>ExternalID</tt></i>:</span></td><td>a NAME* containing the External ID of the DTD</td></tr><tr><td><span class="term"><i><tt>SystemID</tt></i>:</span></td><td>a NAME* containing the URL to the DTD</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting <a href="libxml-tree.html#xmlDtdPtr">xmlDtdPtr</a> or NULL in case of error.</td></tr></tbody></table></div><h3><a name="xmlSAXParseDoc" id="xmlSAXParseDoc"></a>Function: xmlSAXParseDoc</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlSAXParseDoc		(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />					 const <a href="libxml-xmlstring.html#xmlChar">xmlChar</a> * cur, <br />					 int recovery)<br />
</pre><p>parse an XML in-memory document and build a tree. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler block</td></tr><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>a pointer to an array of <a href="libxml-xmlstring.html#xmlChar">xmlChar</a></td></tr><tr><td><span class="term"><i><tt>recovery</tt></i>:</span></td><td>work in recovery mode, i.e. tries to read no Well Formed documents</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlSAXParseEntity" id="xmlSAXParseEntity"></a>Function: xmlSAXParseEntity</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlSAXParseEntity	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />					 const char * filename)<br />
</pre><p>parse an XML external entity out of context and build a tree. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. [78] extParsedEnt ::= TextDecl? content This correspond to a "Well Balanced" chunk</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler block</td></tr><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>the filename</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlSAXParseFile" id="xmlSAXParseFile"></a>Function: xmlSAXParseFile</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlSAXParseFile		(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />					 const char * filename, <br />					 int recovery)<br />
</pre><p>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler block</td></tr><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>the filename</td></tr><tr><td><span class="term"><i><tt>recovery</tt></i>:</span></td><td>work in recovery mode, i.e. tries to read no Well Formed documents</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlSAXParseFileWithData" id="xmlSAXParseFileWithData"></a>Function: xmlSAXParseFileWithData</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlSAXParseFileWithData	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />					 const char * filename, <br />					 int recovery, <br />					 void * data)<br />
</pre><p>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. User data (void *) is stored within the parser context in the context's _private member, so it is available nearly everywhere in libxml</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler block</td></tr><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>the filename</td></tr><tr><td><span class="term"><i><tt>recovery</tt></i>:</span></td><td>work in recovery mode, i.e. tries to read no Well Formed documents</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>the userdata</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlSAXParseMemory" id="xmlSAXParseMemory"></a>Function: xmlSAXParseMemory</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlSAXParseMemory	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />					 const char * buffer, <br />					 int size, <br />					 int recovery)<br />
</pre><p>parse an XML in-memory block and use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler block</td></tr><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>an pointer to a char array</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>the size of the array</td></tr><tr><td><span class="term"><i><tt>recovery</tt></i>:</span></td><td>work in recovery mode, i.e. tries to read not Well Formed documents</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlSAXParseMemoryWithData" id="xmlSAXParseMemoryWithData"></a>Function: xmlSAXParseMemoryWithData</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlSAXParseMemoryWithData	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />						 const char * buffer, <br />						 int size, <br />						 int recovery, <br />						 void * data)<br />
</pre><p>parse an XML in-memory block and use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. User data (void *) is stored within the parser context in the context's _private member, so it is available nearly everywhere in libxml</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler block</td></tr><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>an pointer to a char array</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>the size of the array</td></tr><tr><td><span class="term"><i><tt>recovery</tt></i>:</span></td><td>work in recovery mode, i.e. tries to read no Well Formed documents</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>the userdata</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlSAXUserParseFile" id="xmlSAXUserParseFile"></a>Function: xmlSAXUserParseFile</h3><pre class="programlisting">int	xmlSAXUserParseFile		(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />					 void * user_data, <br />					 const char * filename)<br />
</pre><p>parse an XML file and call the given SAX handler routines. Automatic support for ZLIB/Compress compressed document is provided</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>a SAX handler</td></tr><tr><td><span class="term"><i><tt>user_data</tt></i>:</span></td><td>The user data returned on SAX callbacks</td></tr><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>a file name</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or a error number otherwise</td></tr></tbody></table></div><h3><a name="xmlSAXUserParseMemory" id="xmlSAXUserParseMemory"></a>Function: xmlSAXUserParseMemory</h3><pre class="programlisting">int	xmlSAXUserParseMemory		(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />					 void * user_data, <br />					 const char * buffer, <br />					 int size)<br />
</pre><p>A better SAX parsing routine. parse an XML in-memory buffer and call the given SAX handler routines.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>a SAX handler</td></tr><tr><td><span class="term"><i><tt>user_data</tt></i>:</span></td><td>The user data returned on SAX callbacks</td></tr><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>an in-memory XML document input</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>the length of the XML document in bytes</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or a error number otherwise</td></tr></tbody></table></div><h3><a name="xmlSetExternalEntityLoader" id="xmlSetExternalEntityLoader"></a>Function: xmlSetExternalEntityLoader</h3><pre class="programlisting">void	xmlSetExternalEntityLoader	(<a href="libxml-parser.html#xmlExternalEntityLoader">xmlExternalEntityLoader</a> f)<br />
</pre><p>Changes the defaultexternal entity resolver function for the application</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>f</tt></i>:</span></td><td>the new entity resolver function</td></tr></tbody></table></div><h3><a name="xmlSetFeature" id="xmlSetFeature"></a>Function: xmlSetFeature</h3><pre class="programlisting">int	xmlSetFeature			(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />					 const char * name, <br />					 void * value)<br />
</pre><p>Change the current value of one feature of this parser instance</p>
<div class="variablelist"><table bo